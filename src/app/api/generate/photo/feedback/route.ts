import { NextResponse } from "next/server";
import { getServiceClient } from "@/lib/supabase";
import { getOrgBySlug } from "@/lib/db-queries";

/**
 * Thumbs up/down feedback on a generated image.
 * Thumbs down refunds the generation credit. Changing from down→up re-reserves.
 */
export async function POST(request: Request) {
  try {
    const { generatedImageId, vote, sessionId, orgSlug } = await request.json();

    if (!generatedImageId || !sessionId || !orgSlug || (vote !== 1 && vote !== -1)) {
      return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
    }

    const supabase = getServiceClient();

    // Validate org
    const org = await getOrgBySlug(orgSlug);
    if (!org) return NextResponse.json({ error: "Not found" }, { status: 404 });

    // Validate session belongs to org
    const { data: session } = await supabase
      .from("buyer_sessions")
      .select("id, org_id, generation_count")
      .eq("id", sessionId)
      .single();

    if (!session || session.org_id !== org.id) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }

    // Validate generated image exists, belongs to this org, and was generated by this session
    const { data: image } = await supabase
      .from("generated_images")
      .select("id")
      .eq("id", generatedImageId)
      .eq("org_id", org.id)
      .eq("buyer_session_id", sessionId)
      .single();

    if (!image) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }

    // Check existing feedback
    const { data: existing } = await supabase
      .from("generation_feedback")
      .select("id, vote, credit_refunded")
      .eq("generated_image_id", generatedImageId)
      .eq("buyer_session_id", sessionId)
      .single();

    let creditsUsed = session.generation_count;

    if (existing) {
      const oldVote = existing.vote;
      const wasRefunded = existing.credit_refunded;

      // Update vote
      await supabase
        .from("generation_feedback")
        .update({ vote })
        .eq("id", existing.id);

      if (vote === -1 && !wasRefunded) {
        // Thumbs down — refund credit
        const { data: newCount } = await supabase.rpc("refund_generation_credit", {
          p_session_id: sessionId,
        });
        creditsUsed = newCount ?? creditsUsed;

        await supabase
          .from("generation_feedback")
          .update({ credit_refunded: true })
          .eq("id", existing.id);
      } else if (vote === 1 && oldVote === -1 && wasRefunded) {
        // Changed from thumbs down to thumbs up — re-reserve
        const { data: newCount } = await supabase.rpc("reserve_generation_credit", {
          p_session_id: sessionId,
          p_org_id: org.id,
        });
        if (newCount !== null) {
          creditsUsed = newCount;
          // Only mark as not-refunded if re-reserve succeeded
          await supabase
            .from("generation_feedback")
            .update({ credit_refunded: false })
            .eq("id", existing.id);
        }
        // If re-reserve failed (cap reached), keep credit_refunded: true — buyer keeps the refund
      }
    } else {
      // Insert new feedback
      let creditRefunded = false;

      if (vote === -1) {
        const { data: newCount } = await supabase.rpc("refund_generation_credit", {
          p_session_id: sessionId,
        });
        creditsUsed = newCount ?? creditsUsed;
        creditRefunded = true;
      }

      await supabase.from("generation_feedback").insert({
        generated_image_id: generatedImageId,
        buyer_session_id: sessionId,
        org_id: org.id,
        vote,
        credit_refunded: creditRefunded,
      });
    }

    return NextResponse.json({
      creditsUsed,
      creditsTotal: org.generation_cap_per_session ?? 20,
    });
  } catch (error) {
    console.error("[generate/photo/feedback] Error:", error);
    return NextResponse.json({ error: "Failed to process feedback" }, { status: 500 });
  }
}
